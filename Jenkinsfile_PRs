def RELEASE_ID

/*
    pathmind-webapp pipeline
    The pipeline is made up of following steps
    1. Git clone and setup
    2. Build and local tests
    3. Publish Docker and Helm
    4. Optionally deploy to production and test
 */

/*
    Build a docker image
*/
def buildDockerImage(image_name) {
        echo "Building the pathmind Docker Image"
        sh "docker build -t ${image_name} -f ${WORKSPACE}/Dockerfile ${WORKSPACE}/"
}

/*
    Publish a docker image
*/
def publishDockerImage(image_name,DOCKER_TAG) {
	echo "Logging to aws ecr"
	sh "aws ecr get-login --no-include-email --region us-east-1 | sh"
	echo "Creating ECR ${image_name}"                
	sh "aws ecr create-repository --repository-name ${image_name}"
	echo "Tagging and pushing the pathmind Docker Image"                
	sh "docker tag ${image_name} ${DOCKER_REG}/${image_name}:${DOCKER_TAG}"
	sh "docker push ${DOCKER_REG}/${image_name}"
}

/*
    Delete docker image
*/
def deleteDockerImage(image_name) {
	echo "Logging to aws ecr"
	sh "aws ecr get-login --no-include-email --region us-east-1 | sh"
	echo "Deleting ECR ${image_name}"                
	sh "aws ecr delete-repository --repository-name ${image_name} --force"
}

/*
    This is the main pipeline section with the stages of the CI/CD
 */
pipeline {
    triggers { pollSCM('* * * * *') }

    options {
        // Build auto timeout
        timeout(time: 60, unit: 'MINUTES')
    }

    // Some global default variables
    environment {
        IMAGE_NAME = 'pathmind'
        DOCKER_REG = "839270835622.dkr.ecr.us-east-1.amazonaws.com"
        HELM_FILE = 'values_dev.yaml'
	DEPLOY_PROD = false
    }

    parameters {
        string (name: 'GIT_BRANCH', defaultValue: 'test', description: 'Git branch to build')
        booleanParam (name: 'DEPLOY_TO_PROD', defaultValue: false, description: 'If build and tests are good, proceed and deploy to production without manual approval')

    }

    //all is built and run from the master
    agent { node { label 'master' } }

    // Pipeline stages
    stages {
        stage('Git clone and setup') {
            when {
                allOf{
			expression { env.GIT_BRANCH != 'master' }
			expression { env.GIT_BRANCH != 'dev' }
			expression { env.GIT_BRANCH != 'test' }
                }
            }
            steps {
		script {
                	// Define a unique name for the tests container and helm release
                    	RELEASE_ID = "${IMAGE_NAME}-${env.BUILD_NUMBER}"
                    	echo "Global pathmind Id set to ${RELEASE_ID}"
		}
                echo "Check out code"
		checkout scm

                // Validate kubectl
                sh "kubectl cluster-info"

                // Helm version
                sh "helm version"

		//clean docker
		//sh "docker system prune -a -f"
            }
        }

        stage('Build Docker Images') {
            when {
                allOf{
			expression { env.GIT_BRANCH != 'master' }
			expression { env.GIT_BRANCH != 'dev' }
			expression { env.GIT_BRANCH != 'test' }
                }
            }
		parallel {
			stage('Build pathmind image') {
				steps {
					buildDockerImage("${RELEASE_ID}")
				}
			}
		}
        }

        stage('Publish Docker Images') {
            when {
                allOf{
			expression { env.GIT_BRANCH != 'master' }
			expression { env.GIT_BRANCH != 'dev' }
			expression { env.GIT_BRANCH != 'test' }
                }
            }
		parallel {
			stage('Publish pathmind image') {
				steps {
					publishDockerImage("${RELEASE_ID}","latest")
				}
			}
		}
        } 

	stage('Deploying helm chart') {
            when {
                allOf{
			expression { env.GIT_BRANCH != 'master' }
			expression { env.GIT_BRANCH != 'dev' }
			expression { env.GIT_BRANCH != 'test' }
                }
            }
            steps {
		script {
			echo "Creating name space ${env.BUILD_NUMBER}"
			sh "kubectl create namespace ${env.BUILD_NUMBER}"
			echo "Installing postgresql postgres-${env.BUILD_NUMBER}"
			sh "helm upgrade --install postgres ${WORKSPACE}/infra/helm/postgres --set namespace=${env.BUILD_NUMBER} -n ${env.BUILD_NUMBER}"
			sh "sleep 60"
			echo "Creating secrets"
			sh "kubectl create secret generic dburl --from-literal DB_URL='jdbc:postgresql://postgres/pathminddb?user=pathminddb&password=Asdf1234' -n ${env.BUILD_NUMBER}"
                        sh "kubectl create secret generic awsaccesskey --from-literal AWS_ACCESS_KEY_ID=${env.AWS_ACCESS_KEY_ID} -n ${env.BUILD_NUMBER}"
                        sh "kubectl create secret generic awssecretaccesskey --from-literal AWS_SECRET_ACCESS_KEY=${env.AWS_SECRET_ACCESS_KEY} -n ${env.BUILD_NUMBER}"
                        sh "kubectl create secret generic segmentwebsitekey --from-literal SEGMENT_WEBSITE_KEY=${env.SEGMENT_WEBSITE_KEY} -n ${env.BUILD_NUMBER}"
                        sh "kubectl create secret generic segmentserversitekey --from-literal SEGMENT_SERVER_KEY=${env.SEGMENT_SERVER_KEY} -n ${env.BUILD_NUMBER}"
			echo "Installing ${RELEASE_ID}"
			sh "helm upgrade --install ${RELEASE_ID} ${WORKSPACE}/infra/helm/pathmind -f ${WORKSPACE}/infra/helm/pathmind/${HELM_FILE} --set image.repository=${DOCKER_REG}/${RELEASE_ID} --set image.tag=latest --set env.APPLICATION_URL=http://${RELEASE_ID} --set namespace=${env.BUILD_NUMBER} -n ${env.BUILD_NUMBER}"
			sh "sleep 60"
			echo "Creating user"
			userpass='\\$2a\\$10\\$mnh8uyby0UslZw1fiKXc9uvX2370CJJMjYg3U7ztmVXRXmQo3VJLK'
			sh "echo \"insert into public.pathmind_user (email, password, account_type, email_verified_at) values ('evegeniy@skymind.io', '${userpass}', '0', '2020-02-02 20:24:48.067479') on conflict (email) do nothing;\" > /tmp/${env.BUILD_NUMBER}.sql"
			sh "psql 'host=postgres-${env.BUILD_NUMBER} dbname=pathminddb user=pathminddb password=Asdf1234' < /tmp/${env.BUILD_NUMBER}.sql"
		}
            }
        }

	stage('Testing') {
            when {
                allOf{
			expression { env.GIT_BRANCH != 'master' }
			expression { env.GIT_BRANCH != 'dev' }
			expression { env.GIT_BRANCH != 'test' }
                }
            }
            steps {
		script {
			try {
				echo "Running tests"
				sh "if [ -d pathmind-bdd-tests ]; then rm -rf pathmind-bdd-tests; fi"
				sh "git clone git@github.com:SkymindIO/pathmind-bdd-tests.git"
                                sh "cd pathmind-bdd-tests; mvn clean verify -Dheadless=true -Denvironments.default.base.url=http://${RELEASE_ID}/ -Dpostgresql.host=postgres-${env.BUILD_NUMBER} -Dpostgresql.port=5432 -Dpostgresql.db=pathminddb -Dpostgresql.username=pathminddb -Dpostgresql.password=Asdf1234"
			} catch (err) {
			} finally {
				publishHTML (target: [
				reportDir: 'pathmind-bdd-tests/target/site/serenity',
				reportFiles: 'index.html',
				reportName: "Tests",
                                keepAll:     true,
                                alwaysLinkToLastBuild: true,
                                allowMissing: false
				])
			}
		}
            }
        }

	stage('Destroying') {
            when {
                allOf{
			expression { env.GIT_BRANCH != 'master' }
			expression { env.GIT_BRANCH != 'dev' }
			expression { env.GIT_BRANCH != 'test' }
                }
            }
            steps {
		script {
			echo "Deleting image"
			deleteDockerImage("${RELEASE_ID}")
			echo "Deleting name space ${env.BUILD_NUMBER}"
			sh "helm delete postgres -n ${env.BUILD_NUMBER}"
			sh "helm delete ${RELEASE_ID} -n ${env.BUILD_NUMBER}"
			sh "kubectl delete namespace ${env.BUILD_NUMBER}"
		}
            }
        }
   }
}
