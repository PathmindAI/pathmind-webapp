def RELEASE_ID
def TEST_STATUS=0

/*
    pathmind-webapp pipeline
    The pipeline is made up of following steps
    1. Git clone and setup
    2. Build and local tests
    3. Publish Docker and Helm
    4. Optionally deploy to production and test
 */

/*
    Build a docker image
*/
def buildDockerImage(image_name) {
        echo "Building the pathmind Docker Image"
        sh "docker build -t base -f ${WORKSPACE}/Dockerfile-cache ${WORKSPACE}/"
        sh "docker build -t ${image_name} -f ${WORKSPACE}/Dockerfile ${WORKSPACE}/"
}

/*
    Publish a docker image
*/
def publishDockerImage(image_name,DOCKER_TAG) {
	echo "Logging to aws ecr"
	sh "aws ecr get-login --no-include-email --region us-east-1 | sh"
	echo "Creating ECR ${image_name}"                
	sh "aws ecr create-repository --repository-name ${image_name}"
	echo "Tagging and pushing the pathmind Docker Image"                
	sh "docker tag ${image_name} ${DOCKER_REG}/${image_name}:${DOCKER_TAG}"
	sh "docker push ${DOCKER_REG}/${image_name}"
}

/*
    Delete docker image
*/
def deleteDockerImage(image_name) {
	echo "Logging to aws ecr"
	sh "aws ecr get-login --no-include-email --region us-east-1 | sh"
	echo "Deleting ECR ${image_name}"                
	sh "aws ecr delete-repository --repository-name ${image_name} --force"
}

/*
    This is the main pipeline section with the stages of the CI/CD
 */
pipeline {
    options {
        // Build auto timeout
        timeout(time: 1440, unit: 'MINUTES')
    }

    // Some global default variables
    environment {
        IMAGE_NAME = 'pathmind'
        DOCKER_REG = "839270835622.dkr.ecr.us-east-1.amazonaws.com"
        HELM_FILE = 'values_dev.yaml'
	DEPLOY_PROD = false
    }

    parameters {
        string (name: 'GIT_BRANCH', defaultValue: 'test', description: 'Git branch to build')
        booleanParam (name: 'DEPLOY_TO_PROD', defaultValue: false, description: 'If build and tests are good, proceed and deploy to production without manual approval')

    }

    //Build from Dockerfile
    agent { node { label 'master' } }

    // Pipeline stages
    stages {
        stage('Git clone and setup') {
            when {
                allOf{
			expression { env.GIT_BRANCH != 'master' }
			expression { env.GIT_BRANCH != 'dev' }
			expression { env.GIT_BRANCH != 'test' }
                }
            }
            steps {
		script {
                	// Define a unique name for the tests container and helm release
                    	RELEASE_ID = "${IMAGE_NAME}-${env.BUILD_NUMBER}"
                    	echo "Global pathmind Id set to ${RELEASE_ID}"
		}
                echo "Check out code"
		checkout scm
            }
        }

        stage('Build Docker Images') {
            when {
                allOf{
			expression { env.GIT_BRANCH != 'master' }
			expression { env.GIT_BRANCH != 'dev' }
			expression { env.GIT_BRANCH != 'test' }
                }
            }
		parallel {
			stage('Build pathmind image') {
				steps {
					buildDockerImage("${RELEASE_ID}")
				}
			}
		}
        }

        stage('Publish Docker Images') {
            when {
                allOf{
			expression { env.GIT_BRANCH != 'master' }
			expression { env.GIT_BRANCH != 'dev' }
			expression { env.GIT_BRANCH != 'test' }
                }
            }
		parallel {
			stage('Publish pathmind image') {
				steps {
					publishDockerImage("${RELEASE_ID}","latest")
				}
			}
		}
        } 

	stage('Deploying helm chart') {
            when {
                allOf{
			expression { env.GIT_BRANCH != 'master' }
			expression { env.GIT_BRANCH != 'dev' }
			expression { env.GIT_BRANCH != 'test' }
                }
            }
            steps {
		script {
                        echo "Creating name space ${env.BUILD_NUMBER}"
                        sh "kubectl create namespace ${env.BUILD_NUMBER}"
                        echo "Installing postgresql postgres-${env.BUILD_NUMBER}"
                        sh "helm upgrade --install postgres ${WORKSPACE}/infra/helm/postgres --set namespace=${env.BUILD_NUMBER} -n ${env.BUILD_NUMBER}"

                        echo "Waiting for psql to come up"
                        sh "timeout 900 bash -c 'while ! pg_isready  -h postgres-${env.BUILD_NUMBER} -q; do sleep 5; done'"

                        echo "Creating user"
                        userpass='\\$2a\\$10\\$mnh8uyby0UslZw1fiKXc9uvX2370CJJMjYg3U7ztmVXRXmQo3VJLK'
                        sh "echo \"insert into public.pathmind_user (email, password, account_type, email_verified_at) values ('evegeniy@skymind.io', '${userpass}', '0', '2020-02-02 20:24:48.067479') on conflict (email) do nothing;\" > /tmp/${env.BUILD_NUMBER}.sql"
                        sh "psql 'host=postgres-${env.BUILD_NUMBER} dbname=pathminddb user=pathminddb password=Asdf1234' < /tmp/${env.BUILD_NUMBER}.sql"

                        echo "Creating secrets"
                        sh "kubectl create secret generic dburl --from-literal DB_URL='jdbc:postgresql://postgres/pathminddb?user=pathminddb&password=Asdf1234' -n ${env.BUILD_NUMBER}"
                        sh "kubectl create secret generic awsaccesskey --from-literal AWS_ACCESS_KEY_ID=${env.AWS_ACCESS_KEY_ID} -n ${env.BUILD_NUMBER}"
                        sh "kubectl create secret generic awssecretaccesskey --from-literal AWS_SECRET_ACCESS_KEY=${env.AWS_SECRET_ACCESS_KEY} -n ${env.BUILD_NUMBER}"
                        sh "kubectl create secret generic segmentwebsitekey --from-literal SEGMENT_WEBSITE_KEY=${env.SEGMENT_WEBSITE_KEY} -n ${env.BUILD_NUMBER}"
                        sh "kubectl create secret generic segmentserversitekey --from-literal SEGMENT_SERVER_KEY=${env.SEGMENT_SERVER_KEY} -n ${env.BUILD_NUMBER}"

                        echo "Installing ${RELEASE_ID}"
                        sh "helm upgrade --install ${RELEASE_ID} ${WORKSPACE}/infra/helm/pathmind -f ${WORKSPACE}/infra/helm/pathmind/${HELM_FILE} --set image.repository=${DOCKER_REG}/${RELEASE_ID} --set image.tag=latest --set env.APPLICATION_URL=http://${RELEASE_ID} --set namespace=${env.BUILD_NUMBER} --set env.JOB_MOCK_CYCLE=3 -n ${env.BUILD_NUMBER}"

                        echo "Waiting for webapp to come up"
                        sh "timeout 300 bash -c 'while ! curl http://${RELEASE_ID}; do sleep 5; done'"
		}
            }
        }

	stage('Testing') {
            when {
                allOf{
			expression { env.GIT_BRANCH != 'master' }
			expression { env.GIT_BRANCH != 'dev' }
			expression { env.GIT_BRANCH != 'test' }
                }
            }
            steps {
		script {
			try {
				echo "Running tests"
				sh "if [ -d pathmind-bdd-tests ]; then rm -rf pathmind-bdd-tests; fi"
				sh "git clone git@github.com:SkymindIO/pathmind-bdd-tests.git"
				//Check if there is abranch with the same name in the bdd repository
				EXIT_CODE = sh( returnStatus: true, script: "cd pathmind-bdd-tests && git checkout ${env.ghprbSourceBranch}")
				TEST_STATUS = sh( returnStatus: true, script: "cd pathmind-bdd-tests && mvn clean verify -Dheadless=true -Denvironments.default.base.url=http://${RELEASE_ID}/ -Dpostgresql.host=postgres-${env.BUILD_NUMBER} -Dpostgresql.port=5432 -Dpostgresql.db=pathminddb -Dpostgresql.username=pathminddb -Dpostgresql.password=Asdf1234 -Dhttp.keepAlive=false")
			} catch (err) {
			} finally {
				publishHTML (target: [
				reportDir: 'pathmind-bdd-tests/target/site/serenity',
				reportFiles: 'index.html',
				reportName: "Tests",
                                keepAll:     true,
                                alwaysLinkToLastBuild: true,
                                allowMissing: false
				])
			}

		}
            }
        }

	stage('Destroying') {
            when {
                allOf{
			expression { env.GIT_BRANCH != 'master' }
			expression { env.GIT_BRANCH != 'dev' }
			expression { env.GIT_BRANCH != 'test' }
                }
            }
            steps {
		script {
			echo "Deleting image"
			deleteDockerImage("${RELEASE_ID}")
			echo "Deleting name space ${env.BUILD_NUMBER}"
			sh "helm delete postgres -n ${env.BUILD_NUMBER}"
			sh "helm delete ${RELEASE_ID} -n ${env.BUILD_NUMBER}"
			sh "kubectl delete namespace ${env.BUILD_NUMBER}"
		}
            }
        }

        stage('Set pipeline status') {
            when {
                allOf{
                        expression { env.GIT_BRANCH != 'master' }
                        expression { env.GIT_BRANCH != 'dev' }
                        expression { env.GIT_BRANCH != 'test' }
                }
            }
            steps {
                script {
                        if(TEST_STATUS != 0){
				echo "Some bdd tests failed ${TEST_STATUS}"
				currentBuild.result = 'UNSTABLE'
                        }
                }
            }
        }
   }
}
